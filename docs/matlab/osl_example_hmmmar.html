---
layout: matlab_wrapper
title: HMM-MAR 1 - Example usage
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>HMM-MAR 1 - Example usage</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-03-28"><meta name="DC.source" content="osl_example_hmmmar.m"></head><body><div class="content"><h1>HMM-MAR 1 - Example usage</h1><!--introduction--><p>HMM-MAR DEMO SCRIPT FOR INFERRING A GROUP SPECTRALLY DEFINED HMM FROM SOURCE SPACE MEG DATA</p><p>This follows the paper: Vidaurre et al, NeuroImage (2016)</p><p>Diego Vidaurre, Feb 2017</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">HMM-MAR on hilbert envelopes</a></li><li><a href="#6">HMM-MAR on raw signals</a></li><li><a href="#10">Analyzing HMM output</a></li></ul></div><p>Initial setup - directory of the data and name of saved HMM-MAR analysis:</p><pre class="codeinput">data_dir = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'hmmmar_example'</span>);
hmmmar_name = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'hmmmar_example'</span>,<span class="string">'hmmmar_demo.mat'</span>);
</pre><p>Set <tt>do_analysis=1</tt> to re-run the analysis, otherwise use precomputed result</p><pre class="codeinput">do_analysis = 0;
</pre><h2 id="3">HMM-MAR on hilbert envelopes</h2><p>As in Baker et al, Elife (2014). Start by loading and preparing the data We are going to concatenate data into a single matrix (if data is too big, the file names can also be provided to the hmmmar function)</p><pre class="codeinput">X = []; <span class="comment">% data, time by regions</span>
T = []; <span class="comment">% length of trials, a vector containing how long is each session/trial/subject</span>

subjects = [1 2 4 5 6 7 8 9]; <span class="comment">% index of the subjects</span>
N = length(subjects);

<span class="keyword">for</span> j = subjects <span class="comment">% iterate through subjects</span>
    file = fullfile(data_dir,[<span class="string">'sub'</span> num2str(j) <span class="string">'.mat'</span>]);
    load(file); <span class="comment">% load the data</span>
    sourcedata = sourcedata' ; <span class="comment">% we need it (time by channels)</span>
    T = [T size(sourcedata,1)]; <span class="comment">% time length of this subject</span>
    <span class="keyword">for</span> i=1:size(sourcedata,2)
        sourcedata(:,i) = abs(hilbert(sourcedata(:,i))); <span class="comment">% Hilbert envelope</span>
    <span class="keyword">end</span>
    sourcedata = zscore(sourcedata); <span class="comment">% standardize subject such that it has mean 0 and stdev 1</span>
    X = [X; sourcedata]; <span class="comment">% concat subject</span>
<span class="keyword">end</span>
</pre><p>Prepare the HMM options and run the HMMMAR</p><pre class="codeinput">options = struct();
options.K = 3; <span class="comment">% number of states</span>
options.order =  0; <span class="comment">% order 0 means a Gaussian distribution (adequate for power time series)</span>
options.covtype = <span class="string">'full'</span>; <span class="comment">% model connectivity</span>
options.zeromean = 0; <span class="comment">% model the mean, i.e. model the "amount of power"</span>
options.cyc = 100;
options.initcyc = 10;
options.initrep = 3;
options.verbose = 1; <span class="comment">% show progress?</span>
<span class="keyword">if</span> do_analysis
    [hmm_env,Gamma_env] = hmmmar(X,T,options);
<span class="keyword">end</span>
</pre><p>Compute the spectral information of the states (power, coherence, etc) using a weighted version of the multitaper Note that we can't get an estimation of the spectra directly from the parameters in this case, as the HMM has been run in wideband power time series</p><pre class="codeinput">options = struct();
options.fpass = [1 40]; <span class="comment">% frequency range we want to look at</span>
options.tapers = [4 7]; <span class="comment">% internal multitaper parameter</span>
options.Fs = 200; <span class="comment">% sampling frequency in hertzs</span>
options.win = 10 * options.Fs; <span class="comment">% window, related to the level of detail in frequency of the estimation</span>

<span class="keyword">if</span> do_analysis
    spectra_env = hmmspectramt(X,T,Gamma_env,options);
<span class="keyword">end</span>
</pre><h2 id="6">HMM-MAR on raw signals</h2><p>As in Vidaurre et al, NeuroImage (2016) Loading and preparing the data We are going to concatenate data into a single matrix (if data is too big, the file names can also be provided to the hmmmar function)</p><pre class="codeinput">X = []; <span class="comment">% data, time by regions</span>
T = []; <span class="comment">% length of trials, a vector containing how long is each session/trial/subject</span>

subjects = [1 2 4 5 6 7 8 9]; <span class="comment">% index of the subjects</span>
N = length(subjects);

<span class="keyword">for</span> j = subjects <span class="comment">% iterate through subjects</span>
    file = fullfile(data_dir,[<span class="string">'sub'</span> num2str(j) <span class="string">'.mat'</span>]);
    load(file); <span class="comment">% load the data</span>
    sourcedata = sourcedata' ; <span class="comment">% we need it (time by channels)</span>
    T = [T size(sourcedata,1)]; <span class="comment">% time length of this subject</span>
    sourcedata = zscore(sourcedata); <span class="comment">% standardize subject such that it has mean 0 and stdev 1</span>
    X = [X; sourcedata]; <span class="comment">% concat subject</span>
<span class="keyword">end</span>
</pre><p>Signs might be arbitrarily flipped, so we need to disambiguate this this is because the intrinsic ambiguity in source-reconstructed signals</p><pre class="codeinput">options = struct();
options.maxlag = 8;
options.noruns = 100;
options.verbose = 0;

[flips,scorepath] = findflip(X,T,options);
X = flipdata(X,T,flips);
</pre><p>And run the HMM-MAR on this</p><pre class="codeinput">options = struct();
options.K = 3; <span class="comment">% number of states</span>
options.order =  4; <span class="comment">% MAR order</span>
options.covtype = <span class="string">'full'</span>;
options.cyc = 100;
options.initcyc = 10;
options.initrep = 3;
options.verbose = 1; <span class="comment">% show progress?</span>
<span class="keyword">if</span> do_analysis
    [hmm_raw,Gamma_raw] = hmmmar(X,T,options);
<span class="keyword">end</span>
</pre><p>Compute the spectral information of the states (power, coherence, etc) Because a MAR model implicitly contains all the spectral information, we can use the parameters to derive power, coherence, phase relations, etc.</p><pre class="codeinput">options = struct();
options.fpass = [1 40]; <span class="comment">% frequency range we want to look at</span>
options.Nf = 100; <span class="comment">% number of frequency bins</span>
options.Fs = 200; <span class="comment">% sampling frequency in hertzs</span>
options.order = 11;

<span class="keyword">if</span> do_analysis
    spectra_raw = hmmspectramar(X,T,[],Gamma_raw,options);
<span class="keyword">end</span>
</pre><h2 id="10">Analyzing HMM output</h2><p>Because the number of cycles was set to such a low number, we reload a previously computed run, which would have taken a bit longer</p><pre class="codeinput">load(hmmmar_name)
</pre><p>Now let's see the state evoked probability, locked to the stimulus the stimulus is saved in the variable onset, which contains a (Tx1) logical vector with 1 when the fingertapping is effected.</p><pre class="codeinput">subjects = [1 2 4 5 6 7 8 9]; <span class="comment">% index of the subjects</span>
Hz = 200; <span class="comment">% sampling frequency</span>
L = 8; <span class="comment">% length of the window around the stimulus (seconds)</span>
window = Hz*L+1;
</pre><p>"evoked state response" around the stimulus, for the envelope run</p><pre class="codeinput">evokedGamma_env = zeros(window,hmm_env.K,length(subjects));
t0 = 0;
<span class="keyword">for</span> j = subjects <span class="comment">% iterate through subjects</span>
    file = fullfile(data_dir,[<span class="string">'sub'</span> num2str(j) <span class="string">'.mat'</span>]);
    load(file,<span class="string">'onset'</span>); <span class="comment">% load the data</span>
    T = length(onset);
    index = t0 + (1:T);
    Gamma_subj = Gamma_env(index,:); <span class="comment">% state time course of this subject</span>
    evokedGamma_env(:,:,j) = evokedStateProbability(onset,T,Gamma_subj,window);
    t0 = t0 + length(index);
<span class="keyword">end</span>
evokedGamma_env = mean(evokedGamma_env,3); <span class="comment">% average across subjects</span>
</pre><p>"evoked state response" around the stimulus, for the envelope run</p><pre class="codeinput">evokedGamma_raw = zeros(window,hmm_env.K,length(subjects));
t0 = 0;
<span class="keyword">for</span> j = subjects <span class="comment">% iterate through subjects</span>
    file = fullfile(data_dir,[<span class="string">'sub'</span> num2str(j) <span class="string">'.mat'</span>]);
    load(file,<span class="string">'onset'</span>); <span class="comment">% load the data</span>
    T = length(onset);
    index = t0 + (1:T-hmm_raw.train.order);
    Gamma_subj = Gamma_raw(index,:); <span class="comment">% state time course of this subject</span>
    evokedGamma_raw(:,:,j) = evokedStateProbability(onset,T,Gamma_subj,window);
    t0 = t0 + length(index);
<span class="keyword">end</span>
evokedGamma_raw = mean(evokedGamma_raw,3); <span class="comment">% average across subjects</span>
</pre><p>And plot both</p><pre class="codeinput">figure(1);
halfwindow = (window-1)/2;
subplot(1,2,1)
plot((-halfwindow:halfwindow)/Hz,evokedGamma_env,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time (s)'</span>,<span class="string">'FontSize'</span>,15)
ylabel(<span class="string">'State probability'</span>,<span class="string">'FontSize'</span>,15)
title(<span class="string">'HMM on envelope'</span>,<span class="string">'FontSize'</span>,17)
ylim([0.05 0.7])
subplot(1,2,2)
plot((-halfwindow:halfwindow)/Hz,evokedGamma_raw,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time (s)'</span>,<span class="string">'FontSize'</span>,15)
ylabel(<span class="string">'State probability'</span>,<span class="string">'FontSize'</span>,15)
title(<span class="string">'HMM-MAR on raw signals'</span>,<span class="string">'FontSize'</span>,17)
ylim([0.05 0.7])
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_01.png" style="width:560px;height:420px;" alt=""> <p>Show the spectral info (power and coherence) for the MAR</p><pre class="codeinput">colors = {<span class="string">'b'</span>,[0.2 0.7 0.2],<span class="string">'r'</span>};

figure(2);clf(2) <span class="comment">% parametric spectra, from the HMM-MAR run</span>
<span class="keyword">for</span> k=1:hmm_env.K
    subplot(2,2,1)
    hold <span class="string">on</span>
    plot(spectra_env.state(k).f,spectra_env.state(k).psd(:,1,1),<span class="string">'Color'</span>,colors{k},<span class="string">'LineWidth'</span>,2);xlim([4 30])
    set(gca,<span class="string">'FontSize'</span>,14)
    hold <span class="string">off</span>
    subplot(2,2,4)
    hold <span class="string">on</span>
    plot(spectra_env.state(k).f,spectra_env.state(k).psd(:,2,2),<span class="string">'Color'</span>,colors{k}',<span class="string">'LineWidth'</span>,2);xlim([4 30])
    set(gca,<span class="string">'FontSize'</span>,14)
    hold <span class="string">off</span>
    subplot(2,2,3)
    hold <span class="string">on</span>
    plot(spectra_env.state(k).f,spectra_env.state(k).coh(:,1,2),<span class="string">'Color'</span>,colors{k},<span class="string">'LineWidth'</span>,2);xlim([4 30])
    set(gca,<span class="string">'FontSize'</span>,14)
    hold <span class="string">off</span>
<span class="keyword">end</span>
subplot(2,2,1)
title(<span class="string">'Power Chan1, HMM-Gaussian'</span>,<span class="string">'FontSize'</span>,16)
subplot(2,2,4)
title(<span class="string">'Power Chan2, HMM-Gaussian'</span>,<span class="string">'FontSize'</span>,16)
subplot(2,2,3)
title(<span class="string">'Coherence, HMM-Gaussian'</span>,<span class="string">'FontSize'</span>,16)


figure(4);clf(4) <span class="comment">% parametric spectra, from the HMM-MAR run</span>
<span class="keyword">for</span> k=1:hmm_env.K
    subplot(2,2,1)
    hold <span class="string">on</span>
    plot(spectra_raw.state(k).f,spectra_raw.state(k).psd(:,1,1),<span class="string">'Color'</span>,colors{k},<span class="string">'LineWidth'</span>,2);xlim([4 30])
    set(gca,<span class="string">'FontSize'</span>,14)
    hold <span class="string">off</span>
    subplot(2,2,4)
    hold <span class="string">on</span>
    plot(spectra_raw.state(k).f,spectra_raw.state(k).psd(:,2,2),<span class="string">'Color'</span>,colors{k}',<span class="string">'LineWidth'</span>,2);xlim([4 30])
    set(gca,<span class="string">'FontSize'</span>,14)
    hold <span class="string">off</span>
    subplot(2,2,3)
    hold <span class="string">on</span>
    plot(spectra_raw.state(k).f,spectra_raw.state(k).coh(:,1,2),<span class="string">'Color'</span>,colors{k},<span class="string">'LineWidth'</span>,2);xlim([4 30])
    set(gca,<span class="string">'FontSize'</span>,14)
    hold <span class="string">off</span>
<span class="keyword">end</span>
set(gca,<span class="string">'FontSize'</span>,14)
subplot(2,2,1)
title(<span class="string">'Power Chan1, HMM-MAR'</span>,<span class="string">'FontSize'</span>,16)
subplot(2,2,4)
title(<span class="string">'Power Chan2, HMM-MAR'</span>,<span class="string">'FontSize'</span>,16)
subplot(2,2,3)
title(<span class="string">'Coherence, HMM-MAR'</span>,<span class="string">'FontSize'</span>,16)
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_02.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="osl_example_hmmmar_03.png" style="width:560px;height:420px;" alt=""> <p>HMM-based Time-frequency analysis</p><pre class="codeinput">[psd_tf,coh_tf] = hmmtimefreq(spectra_raw,evokedGamma_raw,1);
f = spectra_raw.state(1).f ;
indf = f&gt;4 &amp; f&lt;=30;
f = f(indf);

figure(5);clf(5)
subplot(3,1,1)
l = max(max(max(abs(psd_tf(indf,:,1)))),max(max(abs(psd_tf(indf,:,1)))));
imagesc((-halfwindow:halfwindow)/Hz,f,psd_tf(:,indf,1)',[-l l]);colorbar
hold <span class="string">on</span>; plot([0 0],[4 30],<span class="string">'k'</span>); hold <span class="string">off</span>
xlabel(<span class="string">'Time (s)'</span>,<span class="string">'FontSize'</span>,14); ylabel(<span class="string">'Frequency (Hz)'</span>,<span class="string">'FontSize'</span>,14);
title(<span class="string">'Power channel 1'</span>,<span class="string">'FontSize'</span>,16)
subplot(3,1,2)
imagesc((-halfwindow:halfwindow)/Hz,f,psd_tf(:,indf,2)',[-l l]);colorbar
hold <span class="string">on</span>; plot([0 0],[4 30],<span class="string">'k'</span>); hold <span class="string">off</span>
xlabel(<span class="string">'Time (s)'</span>,<span class="string">'FontSize'</span>,14); ylabel(<span class="string">'Frequency (Hz)'</span>,<span class="string">'FontSize'</span>,14);
title(<span class="string">'Power channel 2'</span>,<span class="string">'FontSize'</span>,16)
subplot(3,1,3)
l = max(max(abs(coh_tf(indf,:,1,2))));
imagesc((-halfwindow:halfwindow)/Hz,f,coh_tf(:,indf,1,2)',[-l l]);colorbar
hold <span class="string">on</span>; plot([0 0],[4 30],<span class="string">'k'</span>); hold <span class="string">off</span>
xlabel(<span class="string">'Time (s)'</span>,<span class="string">'FontSize'</span>,14); ylabel(<span class="string">'Frequency (Hz)'</span>,<span class="string">'FontSize'</span>,14);
title(<span class="string">'Coherence'</span>,<span class="string">'FontSize'</span>,16)
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_04.png" style="width:560px;height:420px;" alt=""> <p>Probability of transit between states</p><pre class="codeinput">P = hmm_raw.P;
<span class="keyword">for</span> k=1:3
    P(k,k) = 0;
    P(k,:) = P(k,:) / sum(P(k,:));
<span class="keyword">end</span>
P

figure(6)
imagesc(P);colorbar
title(<span class="string">'Transition probability matrix'</span>,<span class="string">'FontSize'</span>,16)
set(gca,<span class="string">'Xtick'</span>,1:3,<span class="string">'ytick'</span>,1:3,<span class="string">'FontSize'</span>,14)
xlabel(<span class="string">'To'</span>,<span class="string">'FontSize'</span>,16)
ylabel(<span class="string">'From'</span>,<span class="string">'FontSize'</span>,16)
</pre><pre class="codeoutput">
P =

         0    0.3822    0.6178
    0.2984         0    0.7016
    0.4318    0.5682         0

</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_05.png" style="width:560px;height:420px;" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% HMM-MAR 1 - Example usage
%
% HMM-MAR DEMO SCRIPT FOR INFERRING A GROUP SPECTRALLY DEFINED 
% HMM FROM SOURCE SPACE MEG DATA
%
% This follows the paper: Vidaurre et al, NeuroImage (2016)
%
% Diego Vidaurre, Feb 2017
%%
% Initial setup - directory of the data and name of saved HMM-MAR analysis:
data_dir = fullfile(osldir,'example_data','hmmmar_example');
hmmmar_name = fullfile(osldir,'example_data','hmmmar_example','hmmmar_demo.mat');

%%
% Set |do_analysis=1| to re-run the analysis, otherwise use precomputed result
do_analysis = 0; 

%% HMM-MAR on hilbert envelopes 
% As in Baker et al, Elife (2014). Start by loading and preparing the data
% We are going to concatenate data into a single matrix
% (if data is too big, the file names can also be provided to the hmmmar function)
X = []; % data, time by regions
T = []; % length of trials, a vector containing how long is each session/trial/subject

subjects = [1 2 4 5 6 7 8 9]; % index of the subjects
N = length(subjects);

for j = subjects % iterate through subjects
    file = fullfile(data_dir,['sub' num2str(j) '.mat']);
    load(file); % load the data
    sourcedata = sourcedata' ; % we need it (time by channels)
    T = [T size(sourcedata,1)]; % time length of this subject
    for i=1:size(sourcedata,2)
        sourcedata(:,i) = abs(hilbert(sourcedata(:,i))); % Hilbert envelope
    end
    sourcedata = zscore(sourcedata); % standardize subject such that it has mean 0 and stdev 1
    X = [X; sourcedata]; % concat subject
end

%%
% Prepare the HMM options and run the HMMMAR
    
options = struct();
options.K = 3; % number of states
options.order =  0; % order 0 means a Gaussian distribution (adequate for power time series)
options.covtype = 'full'; % model connectivity
options.zeromean = 0; % model the mean, i.e. model the "amount of power" 
options.cyc = 100;  
options.initcyc = 10;  
options.initrep = 3;  
options.verbose = 1; % show progress?
if do_analysis
    [hmm_env,Gamma_env] = hmmmar(X,T,options);
end

%%
% Compute the spectral information of the states (power, coherence, etc) 
% using a weighted version of the multitaper
% Note that we can't get an estimation of the spectra directly from the
% parameters in this case, as the HMM has been run in wideband power time series

options = struct();
options.fpass = [1 40]; % frequency range we want to look at
options.tapers = [4 7]; % internal multitaper parameter
options.Fs = 200; % sampling frequency in hertzs
options.win = 10 * options.Fs; % window, related to the level of detail in frequency of the estimation

if do_analysis
    spectra_env = hmmspectramt(X,T,Gamma_env,options);
end

%% HMM-MAR on raw signals 
% As in Vidaurre et al, NeuroImage (2016)
% Loading and preparing the data
% We are going to concatenate data into a single matrix
% (if data is too big, the file names can also be provided to the hmmmar function)
X = []; % data, time by regions
T = []; % length of trials, a vector containing how long is each session/trial/subject

subjects = [1 2 4 5 6 7 8 9]; % index of the subjects
N = length(subjects);

for j = subjects % iterate through subjects
    file = fullfile(data_dir,['sub' num2str(j) '.mat']);
    load(file); % load the data
    sourcedata = sourcedata' ; % we need it (time by channels)
    T = [T size(sourcedata,1)]; % time length of this subject
    sourcedata = zscore(sourcedata); % standardize subject such that it has mean 0 and stdev 1
    X = [X; sourcedata]; % concat subject
end

%%
% Signs might be arbitrarily flipped, so we need to disambiguate this
% this is because the intrinsic ambiguity in source-reconstructed signals

options = struct();
options.maxlag = 8;
options.noruns = 100;
options.verbose = 0;

[flips,scorepath] = findflip(X,T,options);
X = flipdata(X,T,flips);

%%
% And run the HMM-MAR on this

options = struct();
options.K = 3; % number of states
options.order =  4; % MAR order 
options.covtype = 'full';
options.cyc = 100;  
options.initcyc = 10;  
options.initrep = 3;
options.verbose = 1; % show progress?
if do_analysis
    [hmm_raw,Gamma_raw] = hmmmar(X,T,options);
end

%%
% Compute the spectral information of the states (power, coherence, etc) 
% Because a MAR model implicitly contains all the spectral information, 
% we can use the parameters to derive power, coherence, phase relations, etc.

options = struct();
options.fpass = [1 40]; % frequency range we want to look at
options.Nf = 100; % number of frequency bins
options.Fs = 200; % sampling frequency in hertzs
options.order = 11;

if do_analysis
    spectra_raw = hmmspectramar(X,T,[],Gamma_raw,options);
end

%% Analyzing HMM output
% Because the number of cycles was set to such a low number, 
% we reload a previously computed run, which would have taken a bit longer

load(hmmmar_name)


%%
% Now let's see the state evoked probability, locked to the stimulus
% the stimulus is saved in the variable onset, which contains a (Tx1)
% logical vector with 1 when the fingertapping is effected. 

subjects = [1 2 4 5 6 7 8 9]; % index of the subjects
Hz = 200; % sampling frequency
L = 8; % length of the window around the stimulus (seconds)
window = Hz*L+1;

%%
% "evoked state response" around the stimulus, for the envelope run
evokedGamma_env = zeros(window,hmm_env.K,length(subjects));
t0 = 0;
for j = subjects % iterate through subjects
    file = fullfile(data_dir,['sub' num2str(j) '.mat']);
    load(file,'onset'); % load the data
    T = length(onset);
    index = t0 + (1:T);
    Gamma_subj = Gamma_env(index,:); % state time course of this subject
    evokedGamma_env(:,:,j) = evokedStateProbability(onset,T,Gamma_subj,window); 
    t0 = t0 + length(index);
end
evokedGamma_env = mean(evokedGamma_env,3); % average across subjects

%%
% "evoked state response" around the stimulus, for the envelope run
evokedGamma_raw = zeros(window,hmm_env.K,length(subjects));
t0 = 0;
for j = subjects % iterate through subjects
    file = fullfile(data_dir,['sub' num2str(j) '.mat']);
    load(file,'onset'); % load the data
    T = length(onset);
    index = t0 + (1:T-hmm_raw.train.order);
    Gamma_subj = Gamma_raw(index,:); % state time course of this subject
    evokedGamma_raw(:,:,j) = evokedStateProbability(onset,T,Gamma_subj,window);
    t0 = t0 + length(index);
end
evokedGamma_raw = mean(evokedGamma_raw,3); % average across subjects
 
%%
% And plot both 
figure(1);
halfwindow = (window-1)/2;
subplot(1,2,1)
plot((-halfwindow:halfwindow)/Hz,evokedGamma_env,'LineWidth',2)
xlabel('Time (s)','FontSize',15)
ylabel('State probability','FontSize',15)
title('HMM on envelope','FontSize',17)
ylim([0.05 0.7])
subplot(1,2,2)
plot((-halfwindow:halfwindow)/Hz,evokedGamma_raw,'LineWidth',2)
xlabel('Time (s)','FontSize',15)
ylabel('State probability','FontSize',15)
title('HMM-MAR on raw signals','FontSize',17)
ylim([0.05 0.7])

%%
% Show the spectral info (power and coherence) for the MAR

colors = {'b',[0.2 0.7 0.2],'r'};

figure(2);clf(2) % parametric spectra, from the HMM-MAR run
for k=1:hmm_env.K
    subplot(2,2,1)
    hold on
    plot(spectra_env.state(k).f,spectra_env.state(k).psd(:,1,1),'Color',colors{k},'LineWidth',2);xlim([4 30])
    set(gca,'FontSize',14)
    hold off
    subplot(2,2,4)
    hold on
    plot(spectra_env.state(k).f,spectra_env.state(k).psd(:,2,2),'Color',colors{k}','LineWidth',2);xlim([4 30])
    set(gca,'FontSize',14)
    hold off
    subplot(2,2,3)
    hold on
    plot(spectra_env.state(k).f,spectra_env.state(k).coh(:,1,2),'Color',colors{k},'LineWidth',2);xlim([4 30])
    set(gca,'FontSize',14)
    hold off
end
subplot(2,2,1)
title('Power Chan1, HMM-Gaussian','FontSize',16)
subplot(2,2,4)
title('Power Chan2, HMM-Gaussian','FontSize',16)
subplot(2,2,3)
title('Coherence, HMM-Gaussian','FontSize',16)


figure(4);clf(4) % parametric spectra, from the HMM-MAR run
for k=1:hmm_env.K
    subplot(2,2,1)
    hold on
    plot(spectra_raw.state(k).f,spectra_raw.state(k).psd(:,1,1),'Color',colors{k},'LineWidth',2);xlim([4 30])
    set(gca,'FontSize',14)
    hold off
    subplot(2,2,4)
    hold on
    plot(spectra_raw.state(k).f,spectra_raw.state(k).psd(:,2,2),'Color',colors{k}','LineWidth',2);xlim([4 30])
    set(gca,'FontSize',14)
    hold off
    subplot(2,2,3)
    hold on
    plot(spectra_raw.state(k).f,spectra_raw.state(k).coh(:,1,2),'Color',colors{k},'LineWidth',2);xlim([4 30])
    set(gca,'FontSize',14)
    hold off
end
set(gca,'FontSize',14)
subplot(2,2,1)
title('Power Chan1, HMM-MAR','FontSize',16)
subplot(2,2,4)
title('Power Chan2, HMM-MAR','FontSize',16)
subplot(2,2,3)
title('Coherence, HMM-MAR','FontSize',16)

%%
% HMM-based Time-frequency analysis

[psd_tf,coh_tf] = hmmtimefreq(spectra_raw,evokedGamma_raw,1);
f = spectra_raw.state(1).f ;
indf = f>4 & f<=30;
f = f(indf);

figure(5);clf(5)
subplot(3,1,1)
l = max(max(max(abs(psd_tf(indf,:,1)))),max(max(abs(psd_tf(indf,:,1)))));
imagesc((-halfwindow:halfwindow)/Hz,f,psd_tf(:,indf,1)',[-l l]);colorbar
hold on; plot([0 0],[4 30],'k'); hold off
xlabel('Time (s)','FontSize',14); ylabel('Frequency (Hz)','FontSize',14);
title('Power channel 1','FontSize',16)
subplot(3,1,2)
imagesc((-halfwindow:halfwindow)/Hz,f,psd_tf(:,indf,2)',[-l l]);colorbar
hold on; plot([0 0],[4 30],'k'); hold off
xlabel('Time (s)','FontSize',14); ylabel('Frequency (Hz)','FontSize',14);
title('Power channel 2','FontSize',16)
subplot(3,1,3)
l = max(max(abs(coh_tf(indf,:,1,2))));
imagesc((-halfwindow:halfwindow)/Hz,f,coh_tf(:,indf,1,2)',[-l l]);colorbar
hold on; plot([0 0],[4 30],'k'); hold off
xlabel('Time (s)','FontSize',14); ylabel('Frequency (Hz)','FontSize',14);
title('Coherence','FontSize',16)


%%
% Probability of transit between states

P = hmm_raw.P; 
for k=1:3
    P(k,k) = 0;
    P(k,:) = P(k,:) / sum(P(k,:));
end
P

figure(6)
imagesc(P);colorbar
title('Transition probability matrix','FontSize',16)
set(gca,'Xtick',1:3,'ytick',1:3,'FontSize',14)
xlabel('To','FontSize',16)
ylabel('From','FontSize',16)
##### SOURCE END #####
--></body></html>