---
layout: matlab_wrapper
title: ROInets 2 - Amplitude envelope connectivity analysis
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>ROInets 2 - Amplitude envelope connectivity analysis</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-03-28"><meta name="DC.source" content="osl_example_roinets_2_manual.m"></head><body><div class="content"><h1>ROInets 2 - Amplitude envelope connectivity analysis</h1><p>This example shows how to examine functional connectivity using amplitude envelope correlations for a signal subject.</p><p>This example shows how to use low-level ROInets functionality to compute parcel timecourses and perform orthogonalization using SPM objects</p><p>First, set up the input file locations</p><pre class="codeinput">spatial_basis_file = fullfile(osldir,<span class="string">'parcellations'</span>,<span class="string">'fmri_d100_parcellation_with_PCC_reduced_2mm_ss5mm_ds8mm.nii.gz'</span>);
data_dir = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'roinets_example'</span>);
output_directory = fullfile(osldir,<span class="string">'practical'</span>,<span class="string">'roinets_demo'</span>);
<span class="keyword">if</span> ~exist(output_directory)
	mkdir(output_directory)
<span class="keyword">end</span>
</pre><p>When ROInets is used with SPM objects, the node timecourses can be stored as online montages. However, this results in new montages being written to the MEEG file on disk. Therefore, we make a copy first to prevent modifying the originals</p><pre class="codeinput">D = spm_eeg_load(fullfile(data_dir,<span class="string">'subject_1'</span>));
D = D.copy(fullfile(output_directory,<span class="string">'subject_1'</span>));
D = D.montage(<span class="string">'switch'</span>,2);
</pre><p>The input MEEG file has 2 online montages, and we select the second one which corresponds to the source-reconstructed data. Note that there are 3559 channels, one for each voxel in the 8mm grid</p><pre class="codeinput">D
</pre><pre class="codeoutput">SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
3559 channels
11251 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/practical/roinets_demo/subject_1.mat

2 online montage(s) setup
Current montage applied (0=none): 2 ,named: "with weights normalisation, class 1"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>We can load the spatial basis file to confirm the grid size and number of parcels. 23x27x23 corresponds to an 8mm grid, and there are 38 brain regions</p><pre class="codeinput">spatial_basis = read_avw(spatial_basis_file);
size(spatial_basis)
</pre><pre class="codeoutput">
ans =

    23    27    23    38

</pre><p>This can also be done using an OSL Parcellation object. The resolution is 8 and n_parcels confirms there are 38 brain regions. n_voxels corresponds to the number of voxels in the template mask - here 3559 agrees with the number of channels in the MEEG object</p><pre class="codeinput">p = parcellation(spatial_basis_file)
</pre><pre class="codeoutput">
p = 

  parcellation with properties:

             weight_mask: [23&times;27&times;23&times;38 double]
           template_mask: [23&times;27&times;23 double]
    template_coordinates: [3559&times;3 double]
          template_fname: '/Users/romesh/oxford_postdoc/toolboxes/osl/std_...'
                  labels: {38&times;1 cell}
             is_weighted: 1
          is_overlapping: 1
              resolution: 8
               n_parcels: 38
                n_voxels: 3559

</pre><p>Our first task is to compute a timecourse for each parcel. This is done using <tt>ROInets.get_node_tcs</tt> e.g. <tt>D = ROInets.get_node_tcs(D,spatial_basis_file,'pca')</tt>. However, the PCA method only works if the parcellation is binary and non-overlapping. Instead of specifying a .nii file, we can specify a matrix of voxel assignments n_voxels x n_parcels. We can assemble this matrix by first constructing a binary parcellation mask (23x27x23x38) and converting this to 3559x38</p><pre class="codeinput">size(p.binarize) <span class="comment">% Binarize the voxel assignments</span>
size(p.to_matrix(p.binarize)) <span class="comment">% Reshape from volume to matrix representation</span>
D = ROInets.get_node_tcs(D,p.to_matrix(p.binarize),<span class="string">'pca'</span>);
</pre><pre class="codeoutput">
ans =

    23    27    23    38


ans =

        3559          38

get_node_tcs:    Finding PCA time course for ROI 1 out of 38

No new channels information : setting channels info automatically.
</pre><p>Now our MEEG object has 38 channels. If we tried to run get_node_tcs again, an error would be thrown because the wrong montage is selected - to repeat, first run <tt>D = D.montage('switch',2)</tt></p><pre class="codeinput">D
</pre><pre class="codeoutput">SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
38 channels
11251 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/practical/roinets_demo/subject_1.mat

3 online montage(s) setup
Current montage applied (0=none): 3 ,named: "Parcellated with weights normalisation, class 1"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>We can extract the timeseries from the D object and compute the parcelwise distribution of power. This can then be displayed as a spatial map, using fslview or using the Parcellation object</p><pre class="codeinput">D = D.montage(<span class="string">'switch'</span>,3);
ts = D(:,:,:);
ts = ft_preproc_bandpassfilter(ts, D.fsample, [8 12], 4, <span class="string">'but'</span>,<span class="string">'twopass'</span>,<span class="string">'no'</span>);
parcel_power = sum(abs(ts),2)/size(ts,2)/(D.time(end)-D.time(1));
p.plot_activation(parcel_power);
<span class="comment">% fname = p.savenii(p.to_vol(parcel_power),fullfile(output_directory,'parcel_power'));</span>
<span class="comment">% fslview(fname)</span>
</pre><pre class="codeoutput">Warning - parcellation is being binarized
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_01.png" style="width:683px;height:605px;" alt=""> <p>This could be compared to the original voxel data</p><pre class="codeinput">D = D.montage(<span class="string">'switch'</span>,2);
ts = D(:,:,:);
ts = ft_preproc_bandpassfilter(ts, D.fsample, [8 12], 4, <span class="string">'but'</span>,<span class="string">'twopass'</span>,<span class="string">'no'</span>);
voxel_power = sum(abs(ts),2)/size(ts,2)/(D.time(end)-D.time(1));
p.plot_activation(voxel_power);
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_02.png" style="width:683px;height:605px;" alt=""> <p>We could also plot seed-based power differences. For example, the first parcel is in the left occipital cortex. We can plot the power difference between this region and all others</p><pre class="codeinput">p.plot_activation(parcel_power-parcel_power(1),0.1);
</pre><pre class="codeoutput">Warning - parcellation is being binarized
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_03.png" style="width:683px;height:605px;" alt=""> <p>Switching back to the parcel montage, we can compute the Hilbert envelope timecourses</p><pre class="codeinput">D = D.montage(<span class="string">'switch'</span>,3);
ts = D(:,:,:);
Hen = hilbenv(ts);
figure
plot(D.time,ts');
xlabel(<span class="string">'Time (s)'</span>)
ylabel(<span class="string">'Raw signal'</span>)
figure
plot(D.time,Hen');
xlabel(<span class="string">'Time (s)'</span>)
ylabel(<span class="string">'Amplitude envelope value'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_04.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="osl_example_roinets_2_manual_05.png" style="width:560px;height:420px;" alt=""> <p>And then can plot the amplitude envelope correlation</p><pre class="codeinput">figure
imagesc(corr(Hen')+diag(nan(38,1)))
axis <span class="string">square</span>
colorbar
title(<span class="string">'Envelope correlation before leakage correction'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_06.png" style="width:560px;height:420px;" alt=""> <p>However, spatial leakage is still an issue</p><pre class="codeinput">figure
imagesc(corr(ts')+diag(nan(38,1)))
axis <span class="string">square</span>
colorbar
set(gca,<span class="string">'CLim'</span>,[-1 1])
title(<span class="string">'Raw correlation before leakage correction'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_07.png" style="width:560px;height:420px;" alt=""> <p>We can correct for spatial leakage using <tt>ROInets.remove_source_leakage</tt> operating on the D file directly. Now, the active montage needs to be the one with the parcel timecourses</p><pre class="codeinput">D = D.montage(<span class="string">'switch'</span>,3);
D = ROInets.remove_source_leakage(D,<span class="string">'symmetric'</span>);
ts_lc = D(:,:,:);
</pre><pre class="codeoutput">No new channels information : setting channels info automatically.
</pre><p>We could also operate on the vector of data directly - this can be useful if your data are not being stored in an MEEG object. The same syntax can be used for <tt>ROInets.get_node_tcs</tt> if your original data are not MEEG objects.</p><pre class="codeinput">ts_lc = ROInets.remove_source_leakage(ts,<span class="string">'symmetric'</span>);
</pre><p>The orthogonalized signals are now uncorrelated</p><pre class="codeinput">figure
imagesc(corr(ts_lc')+diag(nan(38,1)))
axis <span class="string">square</span>
colorbar
set(gca,<span class="string">'CLim'</span>,[-1 1])
title(<span class="string">'Raw correlation after leakage correction'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_08.png" style="width:560px;height:420px;" alt=""> <p>But amplitude envelope correlations are still present</p><pre class="codeinput">Hen_lc = hilbenv(ts_lc);
figure
imagesc(corr(Hen_lc')+diag(nan(38,1)))
axis <span class="string">square</span>
colorbar
title(<span class="string">'Envelope correlation after leakage correction'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_roinets_2_manual_09.png" style="width:560px;height:420px;" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ROInets 2 - Amplitude envelope connectivity analysis
%
% This example shows how to examine functional connectivity using amplitude 
% envelope correlations for a signal subject.
%
% This example shows how to use low-level ROInets functionality to 
% compute parcel timecourses and perform orthogonalization using
% SPM objects
%
% First, set up the input file locations
spatial_basis_file = fullfile(osldir,'parcellations','fmri_d100_parcellation_with_PCC_reduced_2mm_ss5mm_ds8mm.nii.gz');
data_dir = fullfile(osldir,'example_data','roinets_example');
output_directory = fullfile(osldir,'practical','roinets_demo');
if ~exist(output_directory)
	mkdir(output_directory)
end

%%
% When ROInets is used with SPM objects, the node timecourses can be stored
% as online montages. However, this results in new montages being written to 
% the MEEG file on disk. Therefore, we make a copy first to prevent modifying 
% the originals
D = spm_eeg_load(fullfile(data_dir,'subject_1'));
D = D.copy(fullfile(output_directory,'subject_1'));
D = D.montage('switch',2);

%%
% The input MEEG file has 2 online montages, and we select the second one which
% corresponds to the source-reconstructed data. Note that there are 3559 channels,
% one for each voxel in the 8mm grid
D

%%
% We can load the spatial basis file to confirm the grid size and number of parcels.
% 23x27x23 corresponds to an 8mm grid, and there are 38 brain regions
spatial_basis = read_avw(spatial_basis_file);
size(spatial_basis) 

%%
% This can also be done using an OSL Parcellation object. The resolution is 8 and 
% n_parcels confirms there are 38 brain regions. n_voxels corresponds to the number
% of voxels in the template mask - here 3559 agrees with the number of channels in the
% MEEG object
p = parcellation(spatial_basis_file)

%% 
% Our first task is to compute a timecourse for each parcel. This is done using 
% |ROInets.get_node_tcs| e.g. |D = ROInets.get_node_tcs(D,spatial_basis_file,'pca')|.
% However, the PCA method only works if the parcellation is binary and non-overlapping. 
% Instead of specifying a .nii file, we can specify a matrix of voxel assignments
% n_voxels x n_parcels. We can assemble this matrix by first constructing a binary
% parcellation mask (23x27x23x38) and converting this to 3559x38
size(p.binarize) % Binarize the voxel assignments
size(p.to_matrix(p.binarize)) % Reshape from volume to matrix representation
D = ROInets.get_node_tcs(D,p.to_matrix(p.binarize),'pca');

%% 
% Now our MEEG object has 38 channels. If we tried to run get_node_tcs again, 
% an error would be thrown because the wrong montage is selected - to repeat, 
% first run |D = D.montage('switch',2)|
D

%%
% We can extract the timeseries from the D object and compute the parcelwise distribution of power.
% This can then be displayed as a spatial map, using fslview or using the Parcellation object
D = D.montage('switch',3);
ts = D(:,:,:);
ts = ft_preproc_bandpassfilter(ts, D.fsample, [8 12], 4, 'but','twopass','no');
parcel_power = sum(abs(ts),2)/size(ts,2)/(D.time(end)-D.time(1));
p.plot_activation(parcel_power);
% fname = p.savenii(p.to_vol(parcel_power),fullfile(output_directory,'parcel_power'));
% fslview(fname)

%%
% This could be compared to the original voxel data
D = D.montage('switch',2);
ts = D(:,:,:);
ts = ft_preproc_bandpassfilter(ts, D.fsample, [8 12], 4, 'but','twopass','no');
voxel_power = sum(abs(ts),2)/size(ts,2)/(D.time(end)-D.time(1));
p.plot_activation(voxel_power);

%%
% We could also plot seed-based power differences. For example, the first parcel is 
% in the left occipital cortex. We can plot the power difference between this region
% and all others
p.plot_activation(parcel_power-parcel_power(1),0.1);

%%
% Switching back to the parcel montage, we can compute the Hilbert envelope timecourses
D = D.montage('switch',3);
ts = D(:,:,:);
Hen = hilbenv(ts);
figure
plot(D.time,ts');
xlabel('Time (s)')
ylabel('Raw signal')
figure
plot(D.time,Hen');
xlabel('Time (s)')
ylabel('Amplitude envelope value')

%%
% And then can plot the amplitude envelope correlation
figure
imagesc(corr(Hen')+diag(nan(38,1)))
axis square
colorbar
title('Envelope correlation before leakage correction')

%%
% However, spatial leakage is still an issue
figure
imagesc(corr(ts')+diag(nan(38,1)))
axis square
colorbar
set(gca,'CLim',[-1 1])
title('Raw correlation before leakage correction')

%%
% We can correct for spatial leakage using |ROInets.remove_source_leakage|
% operating on the D file directly. Now, the active montage needs to be
% the one with the parcel timecourses
D = D.montage('switch',3);
D = ROInets.remove_source_leakage(D,'symmetric');
ts_lc = D(:,:,:);

%%
% We could also operate on the vector of data directly - this can be useful if
% your data are not being stored in an MEEG object. The same syntax can be used 
% for |ROInets.get_node_tcs| if your original data are not MEEG objects. 
ts_lc = ROInets.remove_source_leakage(ts,'symmetric');

%%
% The orthogonalized signals are now uncorrelated
figure
imagesc(corr(ts_lc')+diag(nan(38,1)))
axis square
colorbar
set(gca,'CLim',[-1 1])
title('Raw correlation after leakage correction')

%%
% But amplitude envelope correlations are still present
Hen_lc = hilbenv(ts_lc);
figure
imagesc(corr(Hen_lc')+diag(nan(38,1)))
axis square
colorbar
title('Envelope correlation after leakage correction')





##### SOURCE END #####
--></body></html>