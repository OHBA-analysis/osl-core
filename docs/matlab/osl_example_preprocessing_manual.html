---
layout: matlab_wrapper
title: osl_example_preprocessing_manual
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Introduction to manual preprocessing in OSL</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-04-18"><meta name="DC.source" content="osl_example_preprocessing_manual.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Introduction to manual preprocessing in OSL</h1><!--introduction--><p>In this practical/template script we will work with a single subject's data from an emotional faces task (data courtesy of Susie Murphy). This is contained in the downloadable zip.file available online.</p><p>Note that this contains the fif file: fifs/sub1_face_sss.fif that has already been SSS Maxfiltered and downsampled to 250 Hz.</p><p>In this example we will take this fif file and run it through a manual preprocessing pipeline</p><p>MWW 2013, adapted and updated by RB 2017</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">SETUP THE MATLAB PATHS</a></li><li><a href="#2">SPECIFY DIRECTORIES AND FILES FOR THIS ANALYSIS</a></li><li><a href="#5">CONVERT FROM FIF TO AN SPM MEEG OBJECT:</a></li><li><a href="#6">LOAD THE SPM M/EEG OBJECT</a></li><li><a href="#7">SOME BASICS ABOUT SPM OBJECTS</a></li><li><a href="#9">DOWNSAMPLE</a></li><li><a href="#10">LOAD THE DOWNSAMPLED SPM MEEG OBJECT</a></li><li><a href="#11">FILTERING</a></li><li><a href="#13">OSLVIEW</a></li><li><a href="#14">AFRICA WITH MANUAL COMPONENT REJECTION</a></li><li><a href="#23">EPOCHING OF DATA</a></li><li><a href="#25">LOAD THE EPOCHED SPM MEEG OBJECT</a></li><li><a href="#29">VISUAL ARTEFACT REJECTION</a></li><li><a href="#31">EXAMINE THE CLEANED EPOCHED DATA</a></li><li><a href="#35">PLOTTING EVENT-RELATED TOPOGRAPHIES AT DEFINED LATENCIES</a></li><li><a href="#37">SOME EXERCISES</a></li></ul></div><h2>SETUP THE MATLAB PATHS<a name="1"></a></h2><pre class="codeinput">osl_startup;
</pre><pre class="codeoutput">Warning: Duplicate directory name:
/Applications/MATLAB_R2016a.app/toolbox/stateflow/stateflow 
</pre><h2>SPECIFY DIRECTORIES AND FILES FOR THIS ANALYSIS<a name="2"></a></h2><pre class="codeinput"><span class="comment">% directory where the data is:</span>
datadir = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'preproc_example'</span>,<span class="string">'manual'</span>);


<span class="comment">% this is the directory the analysis files will be stored in:</span>
workingdir=[datadir];
cmd = [<span class="string">'mkdir '</span> workingdir]; unix(cmd); <span class="comment">% make dir to put the results in</span>

clear <span class="string">fif_files</span> <span class="string">spm_files_basenames</span>;
</pre><pre class="codeoutput">mkdir: /Applications/osl/example_data/preproc_example/manual: File exists
</pre><p>Specify a list of the existing fif files for subjects Note that here we only have 1 subject, but more generally there would be more than one, e.g.: fif_files{1}=[testdir '/fifs/sub1_face_sss.fif']; fif_files{2}=[testdir '/fifs/sub2_face_sss.fif']; etc...</p><pre class="codeinput">fif_files{1}=[datadir <span class="string">'/fifs/sub1_face_sss.fif'</span>];
</pre><p>Setup a list of SPM MEEG object file names to be created, in the same order as spm_files and fif_files: Note that here we only have 1 subject, but more generally there would be more than one, e.g.: spm_files{1}=[workingdir '/spm8_meg1.mat']; spm_files{2}=[workingdir '/spm8_meg1.mat']; etc...</p><pre class="codeinput">spm_files_basenames{1}=[<span class="string">'spm_meg1.mat'</span>];
</pre><h2>CONVERT FROM FIF TO AN SPM MEEG OBJECT:<a name="5"></a></h2><p>The fif file that we are working with is sub1_face_sss.fif. This has already been max-filtered for you and downsampled to 250Hz.</p><p>This will produce a histogram plot showing the number of events detected for each code on the trigger channel. The codes used on the trigger channel for this experiment were:</p><p>1 = Neutral face 2 = Happy face 3 = Fearful face 4 = Motorbike 18 = Introduction screen 11 = Break between blocks 19 = Midway break 12 = Green fixation cross (response trials) 13 = Red fixation cross (following green on response trials) 14 = Red fixation cross (non-response trials)</p><p>For example, there should be 120 motorbike trials, and 80 of each of the face conditions</p><pre class="codeinput"> <span class="keyword">for</span> subnum = 1:length(fif_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="keyword">if</span>(length(fif_files)&gt;0),
    S2=[];
    <span class="keyword">for</span> i=1:length(fif_files), <span class="comment">% loops over subjects</span>

        S2.fif_file=fif_files{i};
        S2.spm_file=spm_files{i};
        S2.trigger_channel_mask=<span class="string">'0000000000111111'</span>; <span class="comment">% binary mask to use on the trigger channel</span>

        <span class="comment">% The conversion to SPM will show a histogram of the event codes</span>
        <span class="comment">% and correspond to those listed below in the epoching section</span>
        [D spm_files{i}] = osl_convert_script(S2);
    <span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% Note that this spmfile is the output from the conversion:</span>
spm_files{1}
</pre><pre class="codeoutput">
SPM12: spm_eeg_convert_4osl (v6190)                12:31:49 - 18/04/2017
========================================================================

SPM12: spm_eeg_convert_4osl (v6190)                12:31:49 - 18/04/2017
========================================================================
	306 MEG channel locations transformed
Reading /Applications/osl/example_data/preproc_example/manual/fifs/sub1_face_sss.fif ...
Opening raw data file /Applications/osl/example_data/preproc_example/manual/fifs/sub1_face_sss.fif...
	Range : 74500 ... 306499  =    298.000 ...  1225.996 secs
...</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_01.png" style="width:640px;height:480px;" alt=""> <h2>LOAD THE SPM M/EEG OBJECT<a name="6"></a></h2><p>Set filenames used in following steps</p><pre class="codeinput"><span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="comment">% load in the SPM MEEG object</span>
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

<span class="comment">% look at the SPM object. Note that it is continuous data, with 232000 time</span>
<span class="comment">% points at 250Hz. We will epoch the data later.</span>
D
</pre><pre class="codeoutput">SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Applications/osl/example_data/preproc_example/manual/spm_meg1.mat

...</pre><h2>SOME BASICS ABOUT SPM OBJECTS<a name="7"></a></h2><p>The above output gives you some basic information about the M/EEG object that has been loaded into workspace. Note that the data values themselves are memory-mapped from spm_meg1.dat and can be accessed by indexing the D object (e.g, D(1,2,3) returns the field strength in the first sensor at the second sample point during the third trial).</p><pre class="codeinput">D.ntrials
<span class="comment">% will return the number of trials.</span>

<span class="comment">% Typing</span>
D.conditions
<span class="comment">% will show the list of condition labels for each trial.</span>

D.condlist
<span class="comment">% will display a list of unique condition labels.</span>

<span class="comment">% If you type</span>
D.chanlabels;
<span class="comment">% , you will see the order and the names of the channels.</span>

D.chantype;
<span class="comment">% will display the type for each channel.</span>

D.size
</pre><pre class="codeoutput">
ans =

     1


ans = 

    'Undefined'

...</pre><p>will show the size of the data matrix (for channels, samples and trials respectively). The size of each dimension separately can be accessed by D.nchannels, D.nsamples and D.ntrials. Note that although the syntax of these commands is similar to those used for accessing the fields of a struct data type in Matlab what?s actually happening here is that these commands evoke special functions called ?methods? and these methods collect and return the requested information from the internal data structure of the D object. The internal structure is not accessible directly when working with the object. This mechanism greatly enhances the robustness.</p><pre class="codeinput"><span class="comment">% Type</span>
methods(<span class="string">'meeg'</span>)
<span class="comment">% for the full list of methods performing operations with the object.</span>

<span class="comment">% For help on any method, type help meeg/method_name to get help about a method.</span>
</pre><pre class="codeoutput">
Methods for class meeg:

Contents        fieldnames      isfield         save            
badchannels     fname           islinked        sconfounds      
badsamples      fnamedat        link            selectchannels  
badtrials       frequencies     meeg            selectdata      
blank           fsample         modality        sensors         
chanlabels      ftraw           montage         size            
chantype        fttimelock      move            subsasgn        
...</pre><h2>DOWNSAMPLE<a name="9"></a></h2><p>(particularly important if movement compensation is used, as this stops you from downsampling when running Maxfilter - but worth doing anyway)</p><pre class="codeinput"><span class="comment">% Set filenames used in following steps</span>
<span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="comment">% By default, the filtered data set will get the prefix 'f' (preceding the</span>
<span class="comment">% first one).</span>
S=[];
<span class="keyword">for</span> subnum=1:length(spm_files), <span class="comment">% iterates over subjects</span>
    S.D=spm_files{subnum};
    S.fsample_new = 150; <span class="comment">% in Hz</span>
    D = spm_eeg_downsample (S);
<span class="keyword">end</span>
</pre><pre class="codeoutput">
SPM12: spm_eeg_downsample (v6016)                  12:31:59 - 18/04/2017
========================================================================
</pre><h2>LOAD THE DOWNSAMPLED SPM MEEG OBJECT<a name="10"></a></h2><p>Set filenames used in following steps</p><pre class="codeinput"><span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/d'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="comment">% load in the SPM MEEG object</span>
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

<span class="comment">% look at the SPM object. Note that it is continuous data, with 139200 time</span>
<span class="comment">% points at 150Hz. We will epoch the data later.</span>
D
</pre><pre class="codeoutput">SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
139200 samples/trial
1 trials
Sampling frequency: 150 Hz
Loaded from file  /Applications/osl/example_data/preproc_example/manual/dspm_meg1.mat

...</pre><h2>FILTERING<a name="11"></a></h2><p>Note that there are some large artefacts. Use the oslview functionality to remove the bad epochs (see the osl_example_africa.m practical for how to do this).</p><pre class="codeinput"><span class="comment">%set filenames used in following steps</span>
<span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/d'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>
</pre><p>First we do a bit of high-pass filtering to remove the worst of the trends The filtered data set will get the prefix 'f' (preceding the first one).</p><pre class="codeinput">S2=[];
S2.D=spm_files{1};
S2.band=<span class="string">'high'</span>;
S2.freq=0.1;
D=spm_eeg_filter(S2);
</pre><pre class="codeoutput">
SPM12: spm_eeg_filter (v5876)                      12:32:03 - 18/04/2017
========================================================================
</pre><h2>OSLVIEW<a name="13"></a></h2><p>Now load oslview. This data has some bad artefacts in. Mark the epochs at around 325s, 380s and 600s as bad. Marking is done by right-clicking in the proximity of the event and click on 'Mark Event'. A first click (green dashed label) marks the begin of a bad period, a nother second click indicates the end (in red). Also, mark the really bad artefacts at the end of the the experiment from about 650 secs to the end. This will mean that we are not using about half of the data. But with such bad artefacts this is the best we can do. We can still obtain good results with what remains. push disk button to save to disk (same name)</p><pre class="codeinput">figure;
D=oslview(D);
keyboard;
snapnow;
</pre> <img vspace="5" hspace="5" src="osl_example_preprocessing_manual_03.png" style="width:1280px;height:670px;" alt=""> <h2>AFRICA WITH MANUAL COMPONENT REJECTION<a name="14"></a></h2><p>Run AFRICA ICA denoising. AFRICA uses independent component analysis to decompose sensor data into a set of maximally independent time courses. Using this framework, sources of interference such as eye-blinks, ECG artefacts and mains noise can be identified and removed from the data. % % In this practical we will use manual artefact rejection by looking at the time courses and sensor topographies of each component and rejecting those that correlate with EOG and ECG measurements. The user interface displays the time course, power spectrum and sensor topography for each component. These components are sorted based on one of a number of metrics, which you can toggle using the dropdown menu.</p><pre class="codeinput"><span class="comment">% Set new SPM MEEG object filenames to be used in following steps</span>
<span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/fd'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>
</pre><p>Scroll through components using the cursor keys. Identify the two components that correlate with the EOG and ECG measurements and mark them for rejection using the red cross. NB: Just close the window when finished to save your results.</p><pre class="codeinput">figure;
<span class="keyword">for</span> subnum = 1:length(spm_files)

    [dirname,filename] = fileparts(spm_files{subnum});

    S = [];
    S.D           = spm_files{subnum};
    S.logfile         = 1;
    S.ica_file        = fullfile(dirname,[filename <span class="string">'_africa'</span>]);
    S.used_maxfilter  = 1;
    S.ident.func      = @identify_artefactual_components_manual;
    S.to_do           = [1 1 1];
    S.ident.artefact_chans = {<span class="string">'EOG'</span>,<span class="string">'ECG'</span>};
    osl_africa(S);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Number of signals: 306
Number of samples: 87824
Calculating covariance...
Reducing dimension...
Selected [ 62 ] dimensions.
Smallest remaining (non-zero) eigenvalue [ 2.25263 ]
Largest remaining (non-zero) eigenvalue [ 19270.6 ]
Sum of removed eigenvalues [ 7.95623 ]
[ 99.9849 ] % of (non-zero) eigenvalues retained.
Whitening...
...</pre><p><img vspace="5" hspace="5" src="AFRICA_HEARTBEAT.png" alt=""> </p><p><img vspace="5" hspace="5" src="AFRICA_EYEMOVEMTS.png" alt=""> </p><p>Now, after having done AFRICA denoising, let's have a look at the differences. AFRICA saved the cleaned data by default with 'A' preceding all other prefixes. However, it also saved an online montage to the current D object. This is what we will use now to have a look.</p><pre class="codeinput"><span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/fd'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>
</pre><p>We load in the SPM M/EEG object</p><pre class="codeinput">subnum = 1;
D = spm_eeg_load(spm_files{subnum});
</pre><p>We load the data in, just switching between RAW and AFRICA denoised version.</p><pre class="codeinput">D_raw=D.montage(<span class="string">'switch'</span>,0);
D_africa=D.montage(<span class="string">'switch'</span>,1);
</pre><p>Now we plot some data to check the differences between raw and denoised data.</p><pre class="codeinput">figure;
subplot(2,1,1);
plot(D_raw.time(1:10000),D_raw(308,1:10000))
title(<span class="string">'ECG channel'</span>)
xlim([10 20]);xlabel(<span class="string">'Time (s)'</span>)

subplot(2,1,2);
plot(D_raw.time(1:10000),D_raw(306,1:10000))
title(<span class="string">'ECG contaminated channel'</span>)
xlim([10 20]);
hold <span class="string">on</span>;
plot(D_africa.time(1:10000),D_africa(306,1:10000),<span class="string">'r'</span>);
xlim([10 20]);xlabel(<span class="string">'Time (s)'</span>);
legend({<span class="string">'Raw'</span> <span class="string">'AFRICA denoised'</span>})
</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_06.png" style="width:1280px;height:800px;" alt=""> <p>The first part of this figure plots the ECG channel included in the recording as reference. In the second part we plot two versions of the same channel, one that shows the raw time series, so without any preprocessing and the other with AFRICA run on it. You can see that there is some commonalities between the ECG and some part of the raw time-series in the data, but that this is gone in the denoised version. So AFRICA has removed most of the ECG contaminated parts in the signal. If this is not the case in your plot, make sure you have indeed removed the first independent component in AFRICA.</p><h2>EPOCHING OF DATA<a name="23"></a></h2><p>Does preliminary epoching for the purpose of finding outliers This is not the final epoching. Instead this sets up the epoch definitions, and performs a temporary epoching for the purpose of doing semi-automated outlier trial rejection (before running the fully automated OAT). The epoch definitions and the continuous data will be kept and passed into OAT. This is so that things like temporal filtering (which is dones as part of OAT) can be done on the continuous data, before the data is epoched inside OAT. Note that this will also remove those trials that overlap with the bad epochs identified using OSLview. Here the epochs are set to be from -1000ms to +2000ms relative to the triggers in the MEG data. We also specify the trigger values for each of the 4 epoch types of interest (motorcycle images, neutral faces, fearful faces, happy faces). The codes used on the trigger channel for this experiment were: 1 = Neutral face 2 = Happy face 3 = Fearful face 4 = Motorbike 18 = Introduction screen 11 = Break between blocks 19 = Midway break 12 = Green fixation cross (response trials) 13 = Red fixation cross (following green on response trials) 14 = Red fixation cross (non-response trials) Note that we're only interested in the first 4 event codes listed here for today's workshop.</p><p>Set filenames used in following step</p><pre class="codeinput"><span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/fd'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="comment">% Iterating over subjects</span>
<span class="keyword">for</span> i=1:length(spm_files),

    <span class="comment">% define the trials we want from the event information</span>
    S2 = [];
    S2.D = spm_files{i};
    D_continuous=spm_eeg_load(S2.D);

    D_continuous=D_continuous.montage(<span class="string">'switch'</span>,0);

    pretrig = -1000; <span class="comment">% epoch start in ms</span>
    posttrig = 2000; <span class="comment">% epoch end in ms</span>
    S2.timewin = [pretrig posttrig];

    <span class="comment">% event definitions</span>
    S2.trialdef(1).conditionlabel = <span class="string">'Neutral face'</span>;
    S2.trialdef(1).eventtype = <span class="string">'STI101_down'</span>;
    S2.trialdef(1).eventvalue = 1;
    S2.trialdef(2).conditionlabel = <span class="string">'Happy face'</span>;
    S2.trialdef(2).eventtype = <span class="string">'STI101_down'</span>;
    S2.trialdef(2).eventvalue = 2;
    S2.trialdef(3).conditionlabel = <span class="string">'Fearful face'</span>;
    S2.trialdef(3).eventtype = <span class="string">'STI101_down'</span>;
    S2.trialdef(3).eventvalue = 3;
    S2.trialdef(4).conditionlabel = <span class="string">'Motorbike'</span>;
    S2.trialdef(4).eventtype = <span class="string">'STI101_down'</span>;
    S2.trialdef(4).eventvalue = 4;

    S2.reviewtrials = 0;
    S2.save = 0;
    S2.epochinfo.padding = 0;
    S2.event = D_continuous.events;
    S2.fsample = D_continuous.fsample;
    S2.timeonset = D_continuous.timeonset;

    [epochinfo.trl, epochinfo.conditionlabels, S3] = spm_eeg_definetrial(S2);

    <span class="comment">% do epoching</span>
    S3=[];
    S3 = epochinfo;
    S3.D = D_continuous;
    D = osl_epoch(S3);
<span class="keyword">end</span>;
</pre><pre class="codeoutput">
	SPM12: spm_eeg_definetrial (v6182)         12:37:06 - 18/04/2017
	----------------------------------------------------------------

SPM12: spm_eeg_epochs (v6183)                      12:37:06 - 18/04/2017
========================================================================
Data type is missing or incorrect, assigning default.
</pre><h2>LOAD THE EPOCHED SPM MEEG OBJECT<a name="25"></a></h2><p>set filenames used in following step. Prefix 'e' is the default prefix for epoched data, followed by the prefixes of preceding preprocessing steps.</p><pre class="codeinput"><span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/efd'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>


D = spm_eeg_load(spm_files{subnum});

<span class="comment">% look at the SPM object. Note that this is now EPOCHED data</span>
D;

<span class="comment">% Display a list of trial types:</span>
D.condlist;

<span class="comment">% Display time points (in seconds) per trial</span>
D.time;

<span class="comment">% Identify trials of a certain type using the indtrial function. E.g.:</span>
motorbike_trls = indtrial(D,<span class="string">'Motorbike'</span>);
</pre><p>Identify channels of certain types using the meegchannels function. E.g. identify the channel indices for the planar gradiometers and for the magnetometers (what you have available may depend on the actual MEG device) (Note that you can use 'MEGMAG' to get the gradiometers, and D.chantype gives you a list of all channel types by index).</p><pre class="codeinput">planars = D.indchantype(<span class="string">'MEGPLANAR'</span>);
magnetos = D.indchantype(<span class="string">'MEGMAG'</span>);
</pre><p>We can access the actual MEG data using the syntax: D(channels, samples, trials). E.g. plot a figure showing all the trials for the motorbike condition in the 135th MEGPLANAR channel. Note that the squeeze function is needed to remove single dimensions for passing to the plot function, and D.time is used to return the time labels of the within trial time points in seconds.</p><pre class="codeinput">figure; plot(D.time,squeeze(D(planars(135),:,motorbike_trls)));
xlabel(<span class="string">'time (seconds)'</span>);
<span class="comment">% We can average over all the motorbike trials to get a rudimentary ERF</span>
<span class="comment">% (Event-Related Field):</span>

figure; plot(D.time,squeeze(mean(D(planars(135),:,motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);
</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_07.png" style="width:640px;height:400px;" alt=""> <img vspace="5" hspace="5" src="osl_example_preprocessing_manual_08.png" style="width:640px;height:400px;" alt=""> <p>As you will notive, the ERFs look pretty bad. However, we should bear in mind that this data is averaging over all data including noisy data segments, channels and trials. To do better than this we need to perform outlier rejection and exclude bad trials (see below).</p><h2>VISUAL ARTEFACT REJECTION<a name="29"></a></h2><p>This runs a Fieldtrip interactive tool.</p><p>- Pass over the first interactive figure as it is the EOG channel - so just press the "quit" button.</p><p>This will bring up another interactive figure which will show the magnetometers. You can choose the metric to display - it is best to stick to the default, which is variance. This metric is then displayed for the different trials (bottom left), the different channels (top right), and for the combination of the two (top left). You need to use this information to identify those trials and channels with high variance and remove them.</p><p>- Remove the worst channel (with highest variance) by drawing a box around it in the top right plot with the mouse. - Now remove the trials with high variance by drawing a box around them in the bottom left plot. - Repeat this until you are happy that there are no more outliers.</p><p>- Press "quit" and repeat the process for the gradiometers.</p><pre class="codeinput"><span class="comment">%set filenames used in following step</span>
<span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/efd'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="comment">% Run the visual artifact rejection</span>
<span class="keyword">for</span> i=1:length(spm_files),
    S2=[];
    S2.D = spm_files{i};
    S2.time_range=[-0.2 0.4];
    D2=osl_rejectvisual(S2);
<span class="keyword">end</span>;
</pre><pre class="codeoutput">No bad channels currently marked.
121 trials of 360 have already been marked as bad.
%%% 1. EOG %%%
mapping condition label "Motorbike" to condition code 1
mapping condition label "Happy face" to condition code 2
mapping condition label "Fearful face" to condition code 3
mapping condition label "Neutral face" to condition code 4
the input is raw data with 323 channels and 239 trials
showing a summary of the data for all channels and trials
computing metric [---------------------------------------------------------]
...</pre><p><img vspace="5" hspace="5" src="OSL_REJ_VISUAL.png" alt=""> </p><h2>EXAMINE THE CLEANED EPOCHED DATA<a name="31"></a></h2><p>We can now repeat the average over all the motorbike trials with the bad trials removed to get a rudimentary ERF (Event-Related Field).</p><pre class="codeinput"><span class="comment">% Set new SPM MEEG object filenames to be used in following steps</span>
<span class="keyword">for</span> subnum = 1:length(spm_files), <span class="comment">% iterates over subjects</span>
    spm_files{subnum}=[workingdir <span class="string">'/efd'</span> spm_files_basenames{subnum}];
<span class="keyword">end</span>

<span class="comment">% load in SPM MEEG object</span>
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

<span class="comment">% switch to montage zero (raw)</span>
D_raw=D.montage(<span class="string">'switch'</span>,0)
planars = D_raw.indchantype(<span class="string">'MEGPLANAR'</span>)
magnetos = D_raw.indchantype(<span class="string">'MEGMAG'</span>)

<span class="comment">% List the marked bad channels</span>
D_raw.badchannels

<span class="comment">% List the marked bad trials</span>
D_raw.badtrials


<span class="comment">% Identify the motorbike trials. Note that indtrial includes good AND bad</span>
<span class="comment">% trials, so bad trials need to be excluded.</span>
good_motorbike_trls = setdiff(D_raw.indtrial(<span class="string">'Motorbike'</span>),D.badtrials);
</pre><pre class="codeoutput">SPM M/EEG data object
Type: single
Transform: time
4 conditions
323 channels
451 samples/trial
360 trials
Sampling frequency: 150 Hz
Loaded from file  /Applications/osl/example_data/preproc_example/manual/efdspm_meg1.mat

...</pre><p>here we switch to online montage 1. Montages are linear combinations of the sensor data (= montage 0) that can be used to do basically any linear operation and be able to switch between different linear mixings Keep in mind that switching is not enough, you need to assign the switched montage a variable (if same it gets overwritten). Without output it will switch, but the D object will not actually change.</p><pre class="codeinput">D_africa=D.montage(<span class="string">'switch'</span>,1)
</pre><pre class="codeoutput">SPM M/EEG data object
Type: single
Transform: time
4 conditions
306 channels
451 samples/trial
360 trials
Sampling frequency: 150 Hz
Loaded from file  /Applications/osl/example_data/preproc_example/manual/efdspm_meg1.mat

...</pre><p>Now let us plot a cleaned rudimentary ERF. After having excluded the bad samples from oslview and the rejected trials from the artifact rejection, data should look much better. Now, even for the epoched data, the online montage for the AFRICA denoised data is still applicable. So let's see how much the task-related activity differs between 'raw' and AFRICA denoised data. You will find that due to averaging there is less of a difference.</p><pre class="codeinput">figure;
subplot(1,2,1);plot(D_raw.time,squeeze(mean(D_raw(planars(135),:,good_motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);ylim([-10 6])
ylabel(D.units(planars(1)));
hold <span class="string">on</span>;
subplot(1,2,1);plot(D_raw.time,squeeze(mean(D_africa(planars(135),:,good_motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);ylim([-10 6])
legend({<span class="string">'Raw'</span> <span class="string">'AFRICA denoised'</span>})

subplot(1,2,2);plot(D_raw.time,squeeze(mean(D_raw(magnetos(49),:,good_motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);ylim([-300 500])
ylabel(D.units(magnetos(1)));
hold <span class="string">on</span>;
subplot(1,2,2);plot(D_africa.time,squeeze(mean(D_africa(magnetos(49),:,good_motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);ylim([-300 500])
legend({<span class="string">'Raw'</span> <span class="string">'AFRICA denoised'</span>})
</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_09.png" style="width:800px;height:400px;" alt=""> <p>Plot a cleaned rudimentary ERF for all sensors</p><pre class="codeinput">figure;
subplot(1,2,1);imagesc(D.time,[],squeeze(mean(D_africa([planars(:)],:,good_motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);
ylabel(<span class="string">'Trials'</span>);colorbar
title(<span class="string">'MEGPLANAR, single trials'</span>)

subplot(1,2,2);imagesc(D.time,[],squeeze(mean(D_africa([magnetos(:)],:,good_motorbike_trls),3)));
xlabel(<span class="string">'time (seconds)'</span>);
ylabel(<span class="string">'Trials'</span>);colorbar
title(<span class="string">'MEGMAG, single trials'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_10.png" style="width:800px;height:600px;" alt=""> <h2>PLOTTING EVENT-RELATED TOPOGRAPHIES AT DEFINED LATENCIES<a name="35"></a></h2><p>To plot a cleaned rudimentary ERF topography at a relatively late latency, do:</p><pre class="codeinput">topo=squeeze(mean(D(:,188,good_motorbike_trls),3));

figure;sensors_topoplot(D,topo,{<span class="string">'MEGPLANAR'</span> <span class="string">'MEGMAG'</span>},1);
</pre><pre class="codeoutput">reading layout from file /Applications/osl/layouts/neuromag306mag.lay
reading layout from file /Applications/osl/layouts/neuromag306mag.lay
</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_11.png" style="width:1000px;height:600px;" alt=""> <p>Plot the same rudimentary ERF topography for AFRICA denoised data</p><pre class="codeinput">topo2=squeeze(mean(D_africa(:,188,good_motorbike_trls),3));

figure;sensors_topoplot(D_africa,topo2,{<span class="string">'MEGPLANAR'</span> <span class="string">'MEGMAG'</span>},1);
</pre><pre class="codeoutput">reading layout from file /Applications/osl/layouts/neuromag306mag.lay
reading layout from file /Applications/osl/layouts/neuromag306mag.lay
</pre><img vspace="5" hspace="5" src="osl_example_preprocessing_manual_12.png" style="width:1000px;height:600px;" alt=""> <h2>SOME EXERCISES<a name="37"></a></h2><p>If you want to play around with the data and the cleaning approaches presented here, have a look at what happens when you remove more independent components during AFRICA. Also you can have a look at the interaction of oslview and AFRICA. For example, if you do not cut out the bad segments during oslview rejection, can you still get decent ERFs in the end? How many independent components would you need to remove to get some ERFs and are they still comparable to the ones generated earlier?</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Introduction to manual preprocessing in OSL
% In this practical/template script we will work with a single subject's
% data from an emotional faces task (data courtesy of Susie Murphy). This
% is contained in the downloadable zip.file available online.
% 
% 
% Note that this contains the fif file: fifs/sub1_face_sss.fif that has
% already been SSS Maxfiltered and downsampled to 250 Hz.
% 
% In this example we will take this fif file and run it through a manual
% preprocessing pipeline
%
% MWW 2013, adapted and updated by RB 2017


%% SETUP THE MATLAB PATHS
osl_startup;

%% SPECIFY DIRECTORIES AND FILES FOR THIS ANALYSIS

% directory where the data is:
datadir = fullfile(osldir,'example_data','preproc_example','manual');


% this is the directory the analysis files will be stored in:
workingdir=[datadir]; 
cmd = ['mkdir ' workingdir]; unix(cmd); % make dir to put the results in
 
clear fif_files spm_files_basenames;

%% 
% Specify a list of the existing fif files for subjects Note that here we
% only have 1 subject, but more generally there would be more than one,
% e.g.: fif_files{1}=[testdir '/fifs/sub1_face_sss.fif'];
% fif_files{2}=[testdir '/fifs/sub2_face_sss.fif']; etc...
fif_files{1}=[datadir '/fifs/sub1_face_sss.fif']; 

%%
% Setup a list of SPM MEEG object file names to be created, in the same
% order as spm_files and fif_files: Note that here we only have 1 subject,
% but more generally there would be more than one, e.g.:
% spm_files{1}=[workingdir '/spm8_meg1.mat']; spm_files{2}=[workingdir
% '/spm8_meg1.mat']; etc...
spm_files_basenames{1}=['spm_meg1.mat'];

%% CONVERT FROM FIF TO AN SPM MEEG OBJECT:
% The fif file that we are working with is sub1_face_sss.fif. This has
% already been max-filtered for you and downsampled to 250Hz.
% 
% This will produce a histogram plot showing the number of events detected
% for each code on the trigger channel. The codes used on the trigger
% channel for this experiment were:
%
% 1 = Neutral face 2 = Happy face 3 = Fearful face 4 = Motorbike 18 =
% Introduction screen 11 = Break between blocks 19 = Midway break 12 =
% Green fixation cross (response trials) 13 = Red fixation cross (following
% green on response trials) 14 = Red fixation cross (non-response trials)
%
% For example, there should be 120 motorbike trials, and 80 of each of the
% face conditions
 for subnum = 1:length(fif_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/' spm_files_basenames{subnum}];
end

if(length(fif_files)>0),
    S2=[];
    for i=1:length(fif_files), % loops over subjects
        
        S2.fif_file=fif_files{i};
        S2.spm_file=spm_files{i};       
        S2.trigger_channel_mask='0000000000111111'; % binary mask to use on the trigger channel
        
        % The conversion to SPM will show a histogram of the event codes
        % and correspond to those listed below in the epoching section
        [D spm_files{i}] = osl_convert_script(S2);
    end;
end;

% Note that this spmfile is the output from the conversion:
spm_files{1}


%% LOAD THE SPM M/EEG OBJECT
% Set filenames used in following steps
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/' spm_files_basenames{subnum}];
end

% load in the SPM MEEG object
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

% look at the SPM object. Note that it is continuous data, with 232000 time
% points at 250Hz. We will epoch the data later.
D


%% SOME BASICS ABOUT SPM OBJECTS
% The above output gives you some basic information about the M/EEG object
% that has been loaded into workspace. Note that the data values themselves
% are memory-mapped from spm_meg1.dat and can be accessed by indexing the D
% object (e.g, D(1,2,3) returns the field strength in the first sensor at
% the second sample point during the third trial).

D.ntrials
% will return the number of trials.

% Typing
D.conditions
% will show the list of condition labels for each trial.

D.condlist
% will display a list of unique condition labels.

% If you type
D.chanlabels;
% , you will see the order and the names of the channels.

D.chantype;
% will display the type for each channel.

D.size
%%
% will show the size of the data matrix (for channels, samples and trials
% respectively). The size of each dimension separately can be accessed by
% D.nchannels, D.nsamples and D.ntrials. Note that although the syntax of
% these commands is similar to those used for accessing the fields of a
% struct data type in Matlab what?s actually happening here is that these
% commands evoke special functions called ?methods? and these methods
% collect and return the requested information from the internal data
% structure of the D object. The internal structure is not accessible
% directly when working with the object. This mechanism greatly enhances
% the robustness.

% Type
methods('meeg')
% for the full list of methods performing operations with the object.

% For help on any method, type help meeg/method_name to get help about a method.


%% DOWNSAMPLE
% (particularly important if movement compensation is used, as this stops
% you from downsampling when running Maxfilter - but worth doing anyway)

% Set filenames used in following steps
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/' spm_files_basenames{subnum}];
end

% By default, the filtered data set will get the prefix 'f' (preceding the
% first one).
S=[];
for subnum=1:length(spm_files), % iterates over subjects
    S.D=spm_files{subnum};
    S.fsample_new = 150; % in Hz
    D = spm_eeg_downsample (S);    
end



%% LOAD THE DOWNSAMPLED SPM MEEG OBJECT
% Set filenames used in following steps
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/d' spm_files_basenames{subnum}];
end

% load in the SPM MEEG object
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

% look at the SPM object. Note that it is continuous data, with 139200 time
% points at 150Hz. We will epoch the data later.
D


%% FILTERING
% Note that there are some large artefacts. Use the oslview functionality
% to remove the bad epochs (see the osl_example_africa.m practical for how
% to do this).
%set filenames used in following steps
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/d' spm_files_basenames{subnum}];
end


%%
% First we do a bit of high-pass filtering to remove the worst of the trends
% The filtered data set will get the prefix 'f' (preceding the first one).
S2=[];
S2.D=spm_files{1};
S2.band='high';
S2.freq=0.1;
D=spm_eeg_filter(S2);

%% OSLVIEW
% Now load oslview. This data has some bad artefacts in. Mark the epochs at
% around 325s, 380s and 600s as bad. Marking is done by right-clicking in
% the proximity of the event and click on 'Mark Event'. A first click
% (green dashed label) marks the begin of a bad period, a nother second
% click indicates the end (in red). Also, mark the really bad artefacts at
% the end of the the experiment from about 650 secs to the end. This will
% mean that we are not using about half of the data. But with such bad
% artefacts this is the best we can do. We can still obtain good results
% with what remains. push disk button to save to disk (same name)
figure;
D=oslview(D);
keyboard;
snapnow;

%% AFRICA WITH MANUAL COMPONENT REJECTION
% Run AFRICA ICA denoising. AFRICA uses independent component analysis to
% decompose sensor data into a set of maximally independent time courses.
% Using this framework, sources of interference such as eye-blinks, ECG
% artefacts and mains noise can be identified and removed from the data. %
% % In this practical we will use manual artefact rejection by looking at
% the time courses and sensor topographies of each component and rejecting
% those that correlate with EOG and ECG measurements. The user
% interface displays the time course, power spectrum and sensor topography
% for each component. These components are sorted based on one of a number
% of metrics, which you can toggle using the dropdown menu.

% Set new SPM MEEG object filenames to be used in following steps
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/fd' spm_files_basenames{subnum}];
end

%%
% Scroll through components using the cursor keys. Identify the two
% components that correlate with the EOG and ECG measurements and mark them
% for rejection using the red cross. NB: Just close the window when
% finished to save your results.
figure;
for subnum = 1:length(spm_files)

    [dirname,filename] = fileparts(spm_files{subnum});

    S = [];
    S.D           = spm_files{subnum};
    S.logfile         = 1;
    S.ica_file        = fullfile(dirname,[filename '_africa']);
    S.used_maxfilter  = 1;
    S.ident.func      = @identify_artefactual_components_manual;
    S.to_do           = [1 1 1];
    S.ident.artefact_chans = {'EOG','ECG'};
    osl_africa(S);
end

%%
% 
% <<AFRICA_HEARTBEAT.png>>
% 

%%
% 
% <<AFRICA_EYEMOVEMTS.png>>
% 


%%
% Now, after having done AFRICA denoising, let's have a look at the
% differences. AFRICA saved the cleaned data by default with 'A' preceding
% all other prefixes. However, it also saved an online montage to the
% current D object. This is what we will use now to have a look.
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/fd' spm_files_basenames{subnum}];
end

%%
% We load in the SPM M/EEG object
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

%%
% We load the data in, just switching between RAW and AFRICA denoised version.
D_raw=D.montage('switch',0);
D_africa=D.montage('switch',1);

%%
% Now we plot some data to check the differences between raw and denoised data. 
figure;
subplot(2,1,1);
plot(D_raw.time(1:10000),D_raw(308,1:10000))
title('ECG channel')
xlim([10 20]);xlabel('Time (s)')

subplot(2,1,2);
plot(D_raw.time(1:10000),D_raw(306,1:10000))
title('ECG contaminated channel')
xlim([10 20]);
hold on;
plot(D_africa.time(1:10000),D_africa(306,1:10000),'r');
xlim([10 20]);xlabel('Time (s)');
legend({'Raw' 'AFRICA denoised'})

%%
% The first part of this figure plots the ECG channel included in the recording as
% reference. In the second part we plot two versions of the same channel,
% one that shows the raw time series, so without any preprocessing and the other 
% with AFRICA run on it. You can see that there is some commonalities between the ECG and 
% some part of the raw time-series in the data, but that this is gone in the denoised version.
% So AFRICA has removed most of the ECG contaminated parts in the signal.
% If this is not the case in your plot, make sure you have indeed removed
% the first independent component in AFRICA.



%% EPOCHING OF DATA
% Does preliminary epoching for the purpose of finding outliers This is not
% the final epoching. Instead this sets up the epoch definitions, and
% performs a temporary epoching for the purpose of doing semi-automated
% outlier trial rejection (before running the fully automated OAT). The
% epoch definitions and the continuous data will be kept and passed into
% OAT. This is so that things like temporal filtering (which is dones as
% part of OAT) can be done on the continuous data, before the data is
% epoched inside OAT. Note that this will also remove those trials that
% overlap with the bad epochs identified using OSLview. Here the epochs are
% set to be from -1000ms to +2000ms relative to the triggers in the MEG
% data. We also specify the trigger values for each of the 4 epoch types of
% interest (motorcycle images, neutral faces, fearful faces, happy faces).
% The codes used on the trigger channel for this experiment were: 1 =
% Neutral face 2 = Happy face 3 = Fearful face 4 = Motorbike 18 =
% Introduction screen 11 = Break between blocks 19 = Midway break 12 =
% Green fixation cross (response trials) 13 = Red fixation cross (following
% green on response trials) 14 = Red fixation cross (non-response trials)
% Note that we're only interested in the first 4 event codes listed here
% for today's workshop.

%%
% Set filenames used in following step
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/fd' spm_files_basenames{subnum}];
end

% Iterating over subjects
for i=1:length(spm_files),

    % define the trials we want from the event information
    S2 = [];
    S2.D = spm_files{i};
    D_continuous=spm_eeg_load(S2.D);
    
    D_continuous=D_continuous.montage('switch',0);
    
    pretrig = -1000; % epoch start in ms
    posttrig = 2000; % epoch end in ms   
    S2.timewin = [pretrig posttrig];

    % event definitions
    S2.trialdef(1).conditionlabel = 'Neutral face';
    S2.trialdef(1).eventtype = 'STI101_down';
    S2.trialdef(1).eventvalue = 1;
    S2.trialdef(2).conditionlabel = 'Happy face';
    S2.trialdef(2).eventtype = 'STI101_down';
    S2.trialdef(2).eventvalue = 2;
    S2.trialdef(3).conditionlabel = 'Fearful face';
    S2.trialdef(3).eventtype = 'STI101_down';
    S2.trialdef(3).eventvalue = 3;
    S2.trialdef(4).conditionlabel = 'Motorbike';
    S2.trialdef(4).eventtype = 'STI101_down';
    S2.trialdef(4).eventvalue = 4;
    
    S2.reviewtrials = 0;
    S2.save = 0;
    S2.epochinfo.padding = 0;
    S2.event = D_continuous.events;
    S2.fsample = D_continuous.fsample;
    S2.timeonset = D_continuous.timeonset;
    
    [epochinfo.trl, epochinfo.conditionlabels, S3] = spm_eeg_definetrial(S2);        
    
    % do epoching
    S3=[];
    S3 = epochinfo;
    S3.D = D_continuous;     
    D = osl_epoch(S3);
end;


%% LOAD THE EPOCHED SPM MEEG OBJECT
% set filenames used in following step. Prefix 'e' is the default prefix
% for epoched data, followed by the prefixes of preceding preprocessing
% steps.
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/efd' spm_files_basenames{subnum}];
end


D = spm_eeg_load(spm_files{subnum});

% look at the SPM object. Note that this is now EPOCHED data
D;

% Display a list of trial types:
D.condlist;

% Display time points (in seconds) per trial
D.time;

% Identify trials of a certain type using the indtrial function. E.g.:
motorbike_trls = indtrial(D,'Motorbike');



%%
% Identify channels of certain types using the meegchannels function. E.g.
% identify the channel indices for the planar gradiometers and for the
% magnetometers (what you have available may depend on the actual MEG
% device) (Note that you can use 'MEGMAG' to get the gradiometers, and
% D.chantype gives you a list of all channel types by index).
% 
planars = D.indchantype('MEGPLANAR');
magnetos = D.indchantype('MEGMAG');

%%
% We can access the actual MEG data using the syntax: D(channels, samples,
% trials). E.g. plot a figure showing all the trials for the motorbike
% condition in the 135th MEGPLANAR channel. Note that the squeeze function
% is needed to remove single dimensions for passing to the plot function,
% and D.time is used to return the time labels of the within trial time
% points in seconds.

figure; plot(D.time,squeeze(D(planars(135),:,motorbike_trls)));
xlabel('time (seconds)');
% We can average over all the motorbike trials to get a rudimentary ERF
% (Event-Related Field):

figure; plot(D.time,squeeze(mean(D(planars(135),:,motorbike_trls),3)));
xlabel('time (seconds)');

%%
% As you will notive, the ERFs look pretty bad. However, we should bear in
% mind that this data is averaging over all data including noisy data
% segments, channels and trials. To do better than this we need to perform
% outlier rejection and exclude bad trials (see below).


%% VISUAL ARTEFACT REJECTION 
% This runs a Fieldtrip interactive tool.
%
% - Pass over the first interactive figure as it is the EOG channel - so
% just press the "quit" button.
%
% This will bring up another interactive figure which will show the
% magnetometers. You can choose the metric to display - it is best to stick
% to the default, which is variance. This metric is then displayed for the
% different trials (bottom left), the different channels (top right), and
% for the combination of the two (top left). You need to use this
% information to identify those trials and channels with high variance and
% remove them.
%
% - Remove the worst channel (with highest variance) by drawing a box
% around it in the top right plot with the mouse. - Now remove the trials
% with high variance by drawing a box around them in the bottom left plot.
% - Repeat this until you are happy that there are no more outliers.
%
% - Press "quit" and repeat the process for the gradiometers.

%set filenames used in following step
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/efd' spm_files_basenames{subnum}];
end

% Run the visual artifact rejection
for i=1:length(spm_files),
    S2=[];
    S2.D = spm_files{i};
    S2.time_range=[-0.2 0.4];
    D2=osl_rejectvisual(S2);
end;

%%
% 
% <<OSL_REJ_VISUAL.png>>
% 

%%  EXAMINE THE CLEANED EPOCHED DATA
% 
% We can now repeat the average over all the motorbike trials with the bad
% trials removed to get a rudimentary ERF (Event-Related Field).

% Set new SPM MEEG object filenames to be used in following steps
for subnum = 1:length(spm_files), % iterates over subjects
    spm_files{subnum}=[workingdir '/efd' spm_files_basenames{subnum}];
end

% load in SPM MEEG object
subnum = 1;
D = spm_eeg_load(spm_files{subnum});

% switch to montage zero (raw)
D_raw=D.montage('switch',0)
planars = D_raw.indchantype('MEGPLANAR')
magnetos = D_raw.indchantype('MEGMAG')

% List the marked bad channels
D_raw.badchannels

% List the marked bad trials
D_raw.badtrials


% Identify the motorbike trials. Note that indtrial includes good AND bad
% trials, so bad trials need to be excluded.
good_motorbike_trls = setdiff(D_raw.indtrial('Motorbike'),D.badtrials);

%%
% here we switch to online montage 1. Montages are linear combinations of
% the sensor data (= montage 0) that can be used to do basically any linear
% operation and be able to switch between different linear mixings
% Keep in mind that switching is not enough, you need to assign the
% switched montage a variable (if same it gets overwritten). Without output
% it will switch, but the D object will not actually change.
D_africa=D.montage('switch',1)

%%
% Now let us plot a cleaned rudimentary ERF. After having excluded the bad samples
% from oslview and the rejected trials from the artifact rejection, data
% should look much better. Now, even for the epoched data, the online
% montage for the AFRICA denoised data is still applicable. So let's see
% how much the task-related activity differs between 'raw' and AFRICA
% denoised data. You will find that due to averaging there is less of a
% difference. 

figure; 
subplot(1,2,1);plot(D_raw.time,squeeze(mean(D_raw(planars(135),:,good_motorbike_trls),3)));
xlabel('time (seconds)');ylim([-10 6])
ylabel(D.units(planars(1)));
hold on;
subplot(1,2,1);plot(D_raw.time,squeeze(mean(D_africa(planars(135),:,good_motorbike_trls),3)));
xlabel('time (seconds)');ylim([-10 6])
legend({'Raw' 'AFRICA denoised'})

subplot(1,2,2);plot(D_raw.time,squeeze(mean(D_raw(magnetos(49),:,good_motorbike_trls),3)));
xlabel('time (seconds)');ylim([-300 500])
ylabel(D.units(magnetos(1)));
hold on;
subplot(1,2,2);plot(D_africa.time,squeeze(mean(D_africa(magnetos(49),:,good_motorbike_trls),3)));
xlabel('time (seconds)');ylim([-300 500])
legend({'Raw' 'AFRICA denoised'})

%%
% Plot a cleaned rudimentary ERF for all sensors
figure; 
subplot(1,2,1);imagesc(D.time,[],squeeze(mean(D_africa([planars(:)],:,good_motorbike_trls),3)));
xlabel('time (seconds)');
ylabel('Trials');colorbar
title('MEGPLANAR, single trials')

subplot(1,2,2);imagesc(D.time,[],squeeze(mean(D_africa([magnetos(:)],:,good_motorbike_trls),3)));
xlabel('time (seconds)');
ylabel('Trials');colorbar
title('MEGMAG, single trials')

%% PLOTTING EVENT-RELATED TOPOGRAPHIES AT DEFINED LATENCIES
% To plot a cleaned rudimentary ERF topography at a relatively late
% latency, do:

topo=squeeze(mean(D(:,188,good_motorbike_trls),3));

figure;sensors_topoplot(D,topo,{'MEGPLANAR' 'MEGMAG'},1);

%%
% Plot the same rudimentary ERF topography for AFRICA denoised data
topo2=squeeze(mean(D_africa(:,188,good_motorbike_trls),3));

figure;sensors_topoplot(D_africa,topo2,{'MEGPLANAR' 'MEGMAG'},1);


%% SOME EXERCISES
% If you want to play around with the data and the cleaning approaches
% presented here, have a look at what happens when you remove more
% independent components during AFRICA. Also you can have a look at the
% interaction of oslview and AFRICA. For example, if you do not cut out the
% bad segments during oslview rejection, can you still get decent ERFs in
% the end? How many independent components would you need to remove to get
% some ERFs and are they still comparable to the ones generated earlier?
##### SOURCE END #####
--></body></html>